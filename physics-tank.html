<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Physics Tank</title>
  <style>
    html,
    body{height:100%;
         background:#0f1724;
         margin:0;
         font-family:Inter,system-ui,Arial}
    #app{display:flex;
         height:100vh}
    #canvasWrap{flex:1;
                background:#0b1220;
                display:flex;
                align-items:stretch}
    canvas{width:100%;
           height:100%;
           display:block}
    #ui{width:320px;
        background:#0f1724;
        color:#e6eef8;
        padding:14px;
        box-sizing:border-box}
    h1{font-size:16px;
       margin:4px 0 10px}
    .row{display:flex;
         gap:8px;
         margin-bottom:8px}
    button:active,
    button.pressed {
    background: #1e2a46;           /* slightly lighter or darker */
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    transform: translateY(1px);    /* gives a ‚Äúpressed-in‚Äù feel */
    border-color: rgba(255,255,255,0.12);
    }
    button, 
    input[type=range]{padding:8px;
                      border-radius:8px;
                      border:1px solid rgba(255,255,255,0.06);
                      background:#172034;color:inherit}
    .small{font-size:13px}
    label{font-size:12px;
          opacity:.9}
    .stat{font-family:monospace;
          font-size:13px;margin-top:8px}
    .hint{font-size:12px;
          opacity:.8;
          margin-top:6px}

    /* Keyboard-style button */
    .keyBtn {
    border-radius: 4px;                       /* sharper edges, key-like */
    background: #1a2335;                      /* a bit flatter background */
    border: 1px solid rgba(255,255,255,0.12); /* slightly brighter border */
    font-family: monospace;                   /* optional, more "key" feel */
    font-size: 14px;
    padding: 6px 10px;
    box-shadow: 0 4px 0 #0b1220;              /* "stem" under the key */
    transition: transform 0.05s, box-shadow 0.05s;
    }

    /* Press effect */
    .keyBtn:active,
    .keyBtn.pressed {
    transform: translateY(2px);               /* pushes down */
    box-shadow: 1 1 1 #0b1220;                /* stem disappears */
    background: #202c46;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="canvasWrap">
      <canvas id="world"></canvas>
    </div>
    <div id="ui">
    <h1 style="display: flex; justify-content: space-between; align-items: center;">
        ‚öõÔ∏è Physics Tank üêü
        <button id="copyBtn" style="background-color: #8561D7;">Copy to üìã</button>
    </h1>
      <div class="row">
        <button id="fling">Fling ü§æ</button>
        <button id="addDisc">Add Disc</button>
        <button id="clear">Clear Screen</button>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="downforce" type="range" min="0" max="2000" value="0">
        <label>Downforce: <span id="downforceVal">0</span> px/s¬≤</label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="grav" type="range" min="0" max="2000" value="500">
        <label>Gravity: <span id="gravVal">500 px¬≥/ms¬≤</span></label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="rest" type="range" min="0" max="1" step="0.01" value="1">
        <label>Coef. of Restitution: <span id="restVal">1</span></label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="friction" type="range" min="0" max="1" step="0.01" value="0">
        <label>Friction: <span id="frictionVal">0</span></label>
      </div>

      <div class="row">
        <button id="fade">No trail üö´</button>  
        <button id="velvector">No Velocity</button>
        <input type="color" id="colorPicker" value="#4488ff">
        <input type="color" id="velColorPicker" value="#ffd166">
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="alpha_downscale" type="range" min="1" max="100" step="1" value="100">
        <label>Trail Length: <span id="alphaDownscaleVal">Infinity</span></label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="discPersistence" type="range" min="1" max="100" step="1" value="100">
        <label>Disc Persistence: <span id="discPersistenceVal">Infinity</span></label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="discRadius" type="range" min="1" max="100" step="1" value="10">
        <label>Disc Radius: <span id="discRadiusVal">20</span></label>
      </div>

      <div class="row">
        <button id="pause">Pause ‚è∏Ô∏è</button>
        <button id="step">Step üë£</button>
        <button id="fill">Fill üé®</button>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="dt" type="range" min="0" max="0.1" step="0.001" value="0.02">
        <label>Œît: <span id="dtVal">0.02</span>s</label>
      </div>

      <div class="row">
        <button id="controls">Show Controls üéÆ</button>
        <button id="Preset #1" class="keyBtn">1</button>
        <button id="Preset #2" class="keyBtn">2</button>
        <button id="Preset #3" class="keyBtn">3</button>
        <button id="Preset #4" class="keyBtn">4</button>
      </div>
      <div class="stat" id="stats">discs: 0 | FPS: 0</div>
    </div>
  </div>

<script>
/****************************************************************
 * Mini Rigid Body Engine
 * - Shapes: Circle and Box (AABB with orientation)
 * - Integrator: Semi-implicit Euler
 * - Collision: Circle-Circle, AABB-AABB (oriented rect), Circle-AABB
 * - Resolution: Impulse-based with positional correction
 * - Simple constraints: world bounds
 ****************************************************************/

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const picker = document.getElementById("colorPicker");
const velPicker = document.getElementById("velColorPicker");
let runningPreset = false;
let entityColor = "#4488ff";
let velColor = "#ffd166"

let W = canvas.width = innerWidth - 320; // leave room for UI
let H = canvas.height = innerHeight;

// Engine 
let mouseDown = false;
let fling = false;
let gravity = 500; // px/s^2
let downforce = 0;
let globalRestitution = 1.0;
let globalFriction = 0.0;
let discRadius = 10;
let alphaDownscale = 100;
let globalFadeOut = 1;
let discPersistence = 100;
let trail = true;
let dt = 0.02;
let last = performance.now();
let paused = false;
let hideVelVector = false;
let fill = false;
let spawnInterval = null;

// Scene
const discs = [];
const segments = [];

function rand(min,max){return Math.random()*(max-min)+min}

// Vector helpers
const v = {
  add:(a,b)=>({x:a.x+b.x,y:a.y+b.y}),
  sub:(a,b)=>({x:a.x-b.x,y:a.y-b.y}),
  mul:(a,s)=>({x:a.x*s,y:a.y*s}),
  dot:(a,b)=>a.x*b.x+a.y*b.y,
  len:(a)=>Math.hypot(a.x,a.y),
  normalize:(a)=>{const L=Math.hypot(a.x,a.y)||1;return {x:a.x/L,y:a.y/L}},
}

class Disc {
    constructor(x, y, opts={}){
        this.pos = {x,y};
        this.pos_old = {x,y}; // used to sweep lines
        this.vel = opts.vel || {x:0.0, y:0.0};
        this.acc = opts.acc || {x:0.0, y:0.0};
        this.acc_new = opts.acc_new || {x:0.0, y:0.0};
        this.r = opts.r ?? 1.0;
        this.r2 = this.r*this.r;

        this.color = opts.color ?? "#4488ff";
        this.persistence = opts.persistence ?? 100;
        this.startPersistence = this.persistence;

        this.density = opts.density ?? 1.0;
        this.mass = this.density * Math.PI * this.r2;
        this.invMass = 1/this.mass;

        this.dragging = opts.dragging ?? false;
    }
}

class Segment {
    constructor(x1, y1, x2, y2, opts={}){
        this.start = {x: x1, y: y1};
        this.end = {x: x2, y: y2};
        this.dx = this.end.x - this.start.x;
        this.dy = this.end.y - this.start.y;
        this.dx2 = this.dx * this.dx;
        this.dy2 = this.dy * this.dy;
        this.len2 = this.dx2 + this.dy2;
        this.color = opts.color || "#8fb7ff"
        this.dragging = opts.dragging || false;
    }
}

// Scene helpers
function addDisc(x, y, opts={}){ 
    const c = new Disc(x, y, opts); 
    discs.push(c); 
    return c;
}

function addSegment(x1, y1, x2, y2, opts={}){ 
    const s = new Segment(x1, y1, x2, y2, opts=opts); 
    segments.push(s); 
    return s;
}

function detectDiscSegmentCollision(c, s) {
    // Precompute vector from start to circle center
    const vx = c.pos.x - s.start.x;
    const vy = c.pos.y - s.start.y;

    // Project onto segment (normalized to [0,1])
    let t = (vx * s.dx + vy * s.dy) / s.len2; // s.len2 = dx*dx + dy*dy (precomputed)
    if (t < 0) t = 0;
    else if (t > 1) t = 1;

    // Closest point
    const px = s.start.x + t * s.dx;
    const py = s.start.y + t * s.dy;

    // Squared distance check (avoids sqrt)
    const dx = c.pos.x - px;
    const dy = c.pos.y - py;
    return dx*dx + dy*dy <= c.r2;
}

function resolveDiscDisc(a, b) {
    // Vector between centers
    const dx = b.pos.x - a.pos.x;
    const dy = b.pos.y - a.pos.y;

    const minDist = a.r + b.r;
    const dist2 = dx*dx + dy*dy;
    if (dist2 >= minDist * minDist) return; // no collision

    const dist = Math.sqrt(dist2) || 1e-8; // avoid division by zero
    const nx = dx / dist; // normal unit vector x
    const ny = dy / dist; // normal unit vector y
    const tx = -ny; // tangent unit vector x
    const ty =  nx; // tangent unit vector y

    const penetration = minDist - dist;
    if (penetration <= 0) return; // not colliding

    // --- 1. Positional correction ---
    const totalInvMass = a.invMass + b.invMass;
    
    if(!a.dragging && !b.dragging){
        const correction = penetration / totalInvMass;
        a.pos.x -= nx * correction * a.invMass;
        a.pos.y -= ny * correction * a.invMass;
        b.pos.x += nx * correction * b.invMass;
        b.pos.y += ny * correction * b.invMass;
    } else if(a.dragging){
        b.pos.x += nx * penetration;
        b.pos.y += ny * penetration;  
    } else {
        a.pos.x -= nx * penetration;
        a.pos.y -= ny * penetration;
    }

    // --- 2. Relative velocity ---
    const rvx = b.vel.x - a.vel.x;
    const rvy = b.vel.y - a.vel.y;
    const velAlongNormal = rvx * nx + rvy * ny;
    const velAlongTang = rvx * tx + rvy * ty;

    // If moving apart, skip
    if (velAlongNormal > 0) return;

    // --- 3. Calculate impulse scalar ---
    const j = -(1 + globalRestitution) * velAlongNormal / totalInvMass;

    // Tangential impulse
    let jt = -velAlongTang / totalInvMass;
    // Coulomb friction: clamp jt by Œº * |j|
    const maxFriction = globalFriction * Math.abs(j);
    if (Math.abs(jt) > maxFriction) {
        jt = jt > 0 ? maxFriction : -maxFriction;
    }

    // --- 4. Apply impulse ---
    const impulseX = j * nx + jt * tx;
    const impulseY = j * ny + jt * ty;

    if(!a.dragging && !b.dragging){
        a.vel.x -= impulseX * a.invMass;
        a.vel.y -= impulseY * a.invMass;

        b.vel.x += impulseX * b.invMass;
        b.vel.y += impulseY * b.invMass;
    } else if(a.dragging){
        b.vel.x += impulseX * totalInvMass;
        b.vel.y += impulseY * totalInvMass;
    } else {
        a.vel.x -= impulseX * totalInvMass;
        a.vel.y -= impulseY * totalInvMass;
    }

}

function resolveDiscSegment(c, s) {
    // Projection factor (clamped 0..1)
    const t = Math.max(0, Math.min(1, ((c.pos.x - s.start.x) * s.dx + (c.pos.y - s.start.y) * s.dy) / (s.dx2 + s.dy2)));

    // Closest point on segment
    const closestX = s.start.x + t * s.dx;
    const closestY = s.start.y + t * s.dy;

    // Vector from closest point to circle center
    let nx = c.pos.x - closestX;
    let ny = c.pos.y - closestY;
    const distSq = nx*nx + ny*ny;
    const radiusSq = c.r2;

    // If not colliding, exit
    if (distSq > radiusSq) return false;

    const dist = Math.sqrt(distSq) || 0.0001; // avoid div by 0

    // Normal vector (unit)
    nx /= dist;
    ny /= dist;
    const tx = -ny;
    const ty = nx;

    // Push circle out of wall
    const penetration = c.r - dist;
    c.pos.x += nx * penetration;
    c.pos.y += ny * penetration;

    // Reflect velocity: v' = v - (1 + e)*(v¬∑n) n
    const velAlongNormal = c.vel.x * nx + c.vel.y * ny;
    const velAlongTang = c.vel.x * tx + c.vel.y * ty;

    const j = -(1 + globalRestitution) * velAlongNormal;
    // Tangential impulse
    let jt = -velAlongTang;
    // Coulomb friction: clamp jt by Œº * |j|
    const maxFriction = globalFriction * Math.abs(j);
    if (Math.abs(jt) > maxFriction) {
        jt = jt > 0 ? maxFriction : -maxFriction;
    }

    // --- 4. Apply impulse ---
    const impulseX = j * nx + jt * tx;
    const impulseY = j * ny + jt * ty;

    c.vel.x += impulseX;
    c.vel.y += impulseY;
}

function resolveTunneledDiscSegment(c, s){
    // Projection factor (clamped 0..1)
    const t = Math.max(0, Math.min(1, ((c.pos_old.x - s.start.x) * s.dx + (c.pos_old.y - s.start.y) * s.dy) / (s.dx2 + s.dy2)));

    // Closest point on segment
    const closestX = s.start.x + t * s.dx;
    const closestY = s.start.y + t * s.dy;

    // Vector from closest point to circle center
    const dx = c.pos_old.x - closestX;
    const dy = c.pos_old.y - closestY;
    const distSq = dx*dx + dy*dy;
    const radiusSq = c.r2;

    const invDistSq = 1/(distSq || 0.0001);

    // Push circle toward wall
    // TODO: Compute intersection point, update to intersection
    c.pos.x = c.pos_old.x;
    c.pos.y = c.pos_old.y;

    // Reflect velocity: v' = v - (1 + e)*(v¬∑n) n
    const weightedDot = (1 + globalRestitution) * (c.vel.x * dx + c.vel.y * dy) * invDistSq;
    c.vel.x = c.vel.x - weightedDot * dx;
    c.vel.y = c.vel.y - weightedDot * dy;
}

function lineIntersect(A,B,C,D){
    const Ax = A.x, Ay = A.y;
    const Bx = B.x, By = B.y;
    const Cx = C.x, Cy = C.y;
    const Dx = D.x, Dy = D.y;

    return ((Dy - Ay)*(Cx - Ax) > (Cy - Ay)*(Dx - Ax)) !==
           ((Dy - By)*(Cx - Bx) > (Cy - By)*(Dx - Bx)) &&
           ((Cy - Ay)*(Bx - Ax) > (By - Ay)*(Cx - Ax)) !==
           ((Dy - Ay)*(Bx - Ax) > (By - Ay)*(Dx - Ax));
}

function distanceCircToSegment(c, s) {
    const seg_start_to_c = {x: c.pos.x - s.start.x, y: c.pos.y - s.start.y};
    const AB = {x: s.dx, y: s.dy};

    const s2 = s.dx2 + s.dy2;
    if (s2 === 0) {
        // A and B are the same point
        return Math.hypot(seg_start_to_c.x, seg_start_to_c.y);
    }

    const t = (seg_start_to_c.x * s.dx + seg_start_to_c.y * s.dy) / s2;

    let closest;
    if (t < 0) {
        closest = s.start;
    } else if (t > 1) {
        closest = s.end;
    } else {
        closest = {x: s.start.x + t * s.dx, y: s.start.y + t * s.dy};
    }

    const distVector = {x: c.pos.x - closest.x, y: c.pos.y - closest.y};
    return Math.hypot(distVector.x, distVector.y);
}

function integrate(disc, dt){
    // velocity verlet

    // update position
    disc.pos_old.x = disc.pos.x;
    disc.pos_old.y = disc.pos.y;
    disc.pos.x += disc.vel.x * dt + 0.5 * disc.acc.x * dt * dt;
    disc.pos.y += disc.vel.y * dt + 0.5 * disc.acc.y * dt * dt;

    // update velocity
    disc.vel.x += 0.5*(disc.acc.x + disc.acc_new.x)*dt;
    disc.vel.y += 0.5*(disc.acc.y + disc.acc_new.y)*dt;

    // update acceleration
    disc.acc = disc.acc_new
    disc.acc_new.x = 0.0; // to be updated on next step
    disc.acc_new.y = 0.0; // to be updated on next step
}

// World bounds collision
function worldBounds(b){
    if(b.pos.x - b.r < 0){
        b.pos.x = b.r; 

        const j = -(1 + globalRestitution) * b.vel.x;
        let jt = -b.vel.y;
        const maxFriction = globalFriction * Math.abs(j);
        if (Math.abs(jt) > maxFriction) {
            jt = jt > 0 ? maxFriction : -maxFriction;
        }
        b.vel.x += j;
        b.vel.y += jt;
    }
    if(b.pos.x + b.r > W){
        b.pos.x = W - b.r;

        const j = -(1 + globalRestitution) * b.vel.x;
        let jt = -b.vel.y;
        const maxFriction = globalFriction * Math.abs(j);
        if (Math.abs(jt) > maxFriction) {
            jt = jt > 0 ? maxFriction : -maxFriction;
        }
        b.vel.x += j;
        b.vel.y += jt;
    }
    if(b.pos.y - b.r < 0){
        b.pos.y = b.r; 

        const j = -(1 + globalRestitution) * b.vel.y;
        let jt = -b.vel.x;
        const maxFriction = globalFriction * Math.abs(j);
        if (Math.abs(jt) > maxFriction) {
            jt = jt > 0 ? maxFriction : -maxFriction;
        }
        b.vel.y += j;
        b.vel.x += jt;
    }
    if(b.pos.y + b.r > H){ 
        b.pos.y = H - b.r;

        const j = -(1 + globalRestitution) * b.vel.y;
        let jt = -b.vel.x;
        const maxFriction = globalFriction * Math.abs(j);
        if (Math.abs(jt) > maxFriction) {
            jt = jt > 0 ? maxFriction : -maxFriction;
        }
        b.vel.y += j;
        b.vel.x += jt;
    }
}

// Main step
function step(){    
    for (let i = discs.length - 1; i >= 0; i--) {
        const c = discs[i];
        if(!c.dragging){
            integrate(c, dt);
            if (c.persistence < 100){
                c.persistence -= globalFadeOut;
            }
            if (c.persistence <= 0) {
                discs.splice(i, 1); // ‚úÖ remove it
            }
        }
    }

    // handle circles that tunnel through segments
    const discSegmentTunneledPairs = [];
    for(let i=0; i<discs.length; i++){
        let closestTunneledSegIdx = -1;
        let lowestTunneledSegDist = 1000000;
        for(let j=0; j<segments.length; j++){
            const c=discs[i];
            const s=segments[j];
            if(lineIntersect(c.pos_old, c.pos, s.start, s.end)){
                segDist = distanceCircToSegment(c, s);
                if(segDist <= lowestTunneledSegDist && !c.dragging){
                    closestTunneledSegIdx = j;
                    lowestTunneledSegDist = segDist;
                }
            }
        }
        if(closestTunneledSegIdx >= 0){
            discSegmentTunneledPairs.push({c: discs[i], s: segments[closestTunneledSegIdx]});
        }
    }
    for(const pair of discSegmentTunneledPairs){
        resolveTunneledDiscSegment(pair.c, pair.s);
    }

    // handle circles colliding with segments
    const discSegmentCollisionPairs = [];
    for(let i=0; i<discs.length; i++){
        for(let j=0; j<segments.length; j++){
            const c=discs[i];
            const s=segments[j];
            if(detectDiscSegmentCollision(c,s)){
                discSegmentCollisionPairs.push({c, s});
            }
        }
    }
    // resolve
    for(const pair of discSegmentCollisionPairs){
        resolveDiscSegment(pair.c, pair.s);
    }

    // circle circle collisions
    // we resolve all circle collisions in order that we detect them anyway
    // so no point in separating collision detection and resolution (yet)
    for(let i=0; i<discs.length; i++){
        for(let j=i+1; j<discs.length; j++){
            const a=discs[i];
            const b=discs[j];
            resolveDiscDisc(a, b);
        }
    }

    // world bounds
    for(const c of discs){
        worldBounds(c);
    }

    // downforce
    for(const c of discs){
        c.acc_new.y += downforce;
    }

    // intra circle gravity
    for(let i=0; i<discs.length; i++){
        for(let j=i+1; j<discs.length; j++){
            const a=discs[i];
            const b=discs[j];
            const dx = a.pos.x - b.pos.x;
            const dy = a.pos.y - b.pos.y;
            const r2 = dx*dx + dy*dy;

            const minDist = a.r + b.r;
            const minDist2 = minDist*minDist;

            let r3;
            if(minDist2 < r2){
                r3 = r2 * Math.sqrt(r2);
            } else {
                r3 = minDist2 * minDist;
            }
            const invr3 = 1/r3;

            const gma = gravity*a.mass;
            const gmb = gravity*b.mass

            a.acc_new.x -= gmb*dx*invr3;
            a.acc_new.y -= gmb*dy*invr3;

            b.acc_new.x += gma*dx*invr3;
            b.acc_new.y += gma*dy*invr3;
            }
        }
    }

// tracks when we are starting to fade-out trails
let fade_trigger = false;

// Rendering
function draw(){
    if(trail){
        const alpha = 1.0/alphaDownscale;
        // if we are letting circle trails fade out...

        // draw canvas as original color if this is the first frame 
        // that we have fade outs
        if(!fade_trigger){
            fade_trigger = true;
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = `rgba(11, 18, 32, 1)`; // last number = alpha (0 transparent, 1 opaque)
            ctx.fillRect(0, 0, W, H);
        }
        if(alphaDownscale != 100){
            // add partially transparent rectangle matching the canvas color
            ctx.fillStyle = `rgba(11, 18, 32, ${alpha})`; // last number = alpha (0 transparent, 1 opaque)
            ctx.fillRect(0, 0, W, H);
        }
    } else {
        // render canvas with no trails by clearing it completely
        fade_trigger = false;
        alpha = 1.0;
        ctx.clearRect(0, 0, W, H);

        ctx.save();

        // background grid
        ctx.globalAlpha = 0.1;
        ctx.strokeStyle = '#fff';
        for(let x=0;x<W;x+=40){
            ctx.beginPath();
            ctx.moveTo(x,0);
            ctx.lineTo(x,H);
            ctx.stroke();
        }

        for(let y=0;y<H;y+=40){
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(W,y);
            ctx.stroke();
        }
        ctx.restore();
    }

    for(const c of discs){
        fractionFaded = c.persistence/c.startPersistence;
        fillAlpha = Math.round(50*fractionFaded).toString().padStart(2, "0");
        strokeAlpha = Math.round(99*fractionFaded).toString().padStart(2, "0");
        if(fill){
            ctx.fillStyle = c.color + fillAlpha;
        } else {
            ctx.fillStyle = `rgba(11, 18, 32, 1)`;
        }
        ctx.strokeStyle = c.color + strokeAlpha;

        ctx.beginPath();
        ctx.arc(c.pos.x, c.pos.y, c.r, 0, Math.PI*2);
        ctx.fill();
        ctx.lineWidth=1.5;
        ctx.stroke();

        // velocity arrow
        if(!hideVelVector){
            ctx.beginPath();
            ctx.moveTo(c.pos.x, c.pos.y);
            ctx.lineTo(c.pos.x + c.vel.x*0.08, c.pos.y + c.vel.y*0.08);
            ctx.strokeStyle=velColor;
            ctx.stroke();
        }
    }

    for(const s of segments){
        ctx.beginPath();
        ctx.moveTo(s.start.x, s.start.y);   // start point
        ctx.lineTo(s.end.x, s.end.y);   // end point
        ctx.strokeStyle=s.color;
        ctx.stroke();
        }
    }

// Loop
function loop(now){
  requestAnimationFrame(loop);
  const elapsed = (now - last) / 1000;
  last = now;
  if(!paused){
    step();
  }
  draw();
  // stats
  const fps = Math.round(1/Math.max(elapsed,1e-6));
  document.getElementById('stats').textContent = `discs: ${discs.length} | segments: ${segments.length} | FPS: ${fps}`;
}

requestAnimationFrame(loop);

// Resize handling
function resize(){ W = canvas.width = innerWidth - 320; H = canvas.height = innerHeight; }
addEventListener('resize', resize);

// UI hooks
picker.addEventListener("input", (event) => {
    const color = event.target.value; // hex string like "#1e90ff"
    entityColor = color;
});
velPicker.addEventListener("input", (event) => {
    const color = event.target.value; // hex string like "#1e90ff"
    velColor = color;
});
document.getElementById('fling').onclick = function(){ fling = !fling; this.textContent = fling ? 'Pour ü´ó' : 'Fling ü§æ';};
document.getElementById('addDisc').onclick = ()=> addDisc(rand(100,W-100), rand(100,H-200), {r:discRadius, color: entityColor, persistence:discPersistence});
document.getElementById('velvector').onclick = function(){ hideVelVector = !hideVelVector; this.textContent = hideVelVector ? 'Velocity üöÄ' : 'No Velocity';};
document.getElementById('clear').onclick = ()=>{ discs.length = 0; segments.length = 0; };
document.getElementById('copyBtn').addEventListener('click', async () => {
    try {
        const blob = await new Promise(res => canvas.toBlob(res));
        await navigator.clipboard.write([
            new ClipboardItem({ 'image/png': blob })
        ]);
        alert('Canvas image copied to clipboard!');
    } catch (err) {
        console.error('Failed to copy image:', err);
    }
});
document.getElementById('controls').addEventListener('click', async () => {
    alert('1. Click+drag disc to move it\n2. Click right mouse and drag to draw walls\n3. In "Fling" mode, click+drag elsewhere to create a moving disc\n4. In "Pour" mode, hold mouse down to continuously add discs\n5. Shift+click to spawn disc without velocity');
});

preset1 = document.getElementById('Preset #1')
preset2 = document.getElementById('Preset #2')
preset3 = document.getElementById('Preset #3')
preset4 = document.getElementById('Preset #4')
preset1.onclick = ()=>{ if(!runningPreset) defaultStart() };
preset2.onclick = ()=>{ if(!runningPreset) tubes() };
preset3.onclick = ()=>{ if(!runningPreset) cascade() };
preset4.onclick = ()=>{ if(!runningPreset) vortex() };

document.getElementById('pause').onclick = function(){ paused = !paused; this.textContent = paused ? 'Play ‚ñ∂Ô∏è' : 'Pause ‚è∏Ô∏è'; };
document.getElementById('step').onclick = ()=>{ if(paused) step(); };
document.getElementById('fill').onclick = function(){ fill = !fill; this.textContent = fill ? 'No Fill ü™π' : 'Fill üé®';};

const gravInput = document.getElementById('grav'); const gravVal = document.getElementById('gravVal');
gravInput.oninput = ()=>{ gravity = Number(gravInput.value); gravVal.textContent = gravity };

const downforceInput = document.getElementById('downforce'); const downforceVal = document.getElementById('downforceVal');
downforceInput.oninput = ()=>{ downforce = Number(downforceInput.value); downforceVal.textContent = downforce };

const restInput = document.getElementById('rest'); const restVal = document.getElementById('restVal');
restInput.oninput = ()=>{ globalRestitution = Number(restInput.value); restVal.textContent = globalRestitution };

const frictionInput = document.getElementById('friction'); const frictionVal = document.getElementById('frictionVal');
frictionInput.oninput = ()=>{ globalFriction = Number(frictionInput.value); frictionVal.textContent = globalFriction };

const dtInput = document.getElementById('dt'); const dtVal = document.getElementById('dtVal');
dtInput.oninput = ()=>{ dt = Number(dtInput.value); dtVal.textContent = dt };

const alphaDownscaleInput = document.getElementById('alpha_downscale'); const alphaDownscaleVal = document.getElementById('alphaDownscaleVal');
alphaDownscaleInput.oninput = ()=>{ alphaDownscale = Number(alphaDownscaleInput.value); alphaDownscaleVal.textContent = alphaDownscale == 100 ? 'Infinity' : alphaDownscale};
document.getElementById('fade').onclick = function(){ trail = !trail; this.textContent = trail ? 'No trail üö´' : 'Trail üêå'; };

const discPersistenceInput = document.getElementById('discPersistence'); const discPersistenceVal = document.getElementById('discPersistenceVal');
discPersistenceInput.oninput = ()=>{ discPersistence = Number(discPersistenceInput.value); discPersistenceVal.textContent = discPersistence == 100 ? 'Infinity' : discPersistence};

const discRadiusInput = document.getElementById('discRadius'); const discRadiusVal = document.getElementById('discRadiusVal');
discRadiusInput.oninput = ()=>{ discRadius = Number(discRadiusInput.value); discRadiusVal.textContent = discRadius };

// Mouse interactions: spawn, drag
canvas.addEventListener('contextmenu', e => e.preventDefault());

let mouse = {x:0,y:0,down:false,start:null,btn:0};

// backspace logic
document.addEventListener('keydown', (e) => {
  if (e.key === 'Backspace') {
    discs.length = 0;
    segments.length = 0;
  }
  else if (e.key == '1'){
    if(!runningPreset) defaultStart();
  } else if (e.key == '2'){
    if(!runningPreset) tubes();
  } else if (e.key == '3'){
    if(!runningPreset) cascade();
  } else if (e.key == '4') {
    if(!runningPreset) vortex();
  }
});

// segment addition logic
canvas.addEventListener('pointerdown', e=>{
    if(e.button == 2){
        s = addSegment(mouse.x, mouse.y, mouse.x, mouse.y, opts={dragging: true, color: entityColor});
    }
})
canvas.addEventListener('pointermove', e=>{
    const rect = canvas.getBoundingClientRect(); 
    mouse.x = e.clientX - rect.left; 
    mouse.y = e.clientY - rect.top;    
    const held_segment = segments.find(s=>s.dragging);
    if(held_segment){
        held_segment.end.x = mouse.x;
        held_segment.end.y = mouse.y;
        held_segment.dx = held_segment.end.x - held_segment.start.x;
        held_segment.dy = held_segment.end.y - held_segment.start.y;
        held_segment.dx2 = held_segment.dx * held_segment.dx;
        held_segment.dy2 = held_segment.dy * held_segment.dy;
        held_segment.len2 = held_segment.dx2 + held_segment.dy2;
    }
})
canvas.addEventListener('pointerup', e=>{
    mouse.down=false;
    const heldSegmentIndex = segments.findIndex(s=>s.dragging);
    if(heldSegmentIndex>=0){ 
        segments[heldSegmentIndex].dragging = false;
    }
});

// disc addition logic
canvas.addEventListener('pointerdown', e=>{
    // left mouse button
    if(e.button == 0){
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left; 
        mouse.y = e.clientY - rect.top; 
        mouse.down=true; 
        mouse.btn=e.button; 
        mouse.start = {x:mouse.x,y:mouse.y};
        // pick body
        const pick = pickDisc(mouse.x, mouse.y);
        if(pick){ 
            pick.dragging = true; 
            pick.dragOffset = {x: mouse.x - pick.pos.x, y: mouse.y - pick.pos.y}; 
        }
        else if(e.shiftKey){ 
            addDisc(mouse.x, mouse.y, {r:discRadius, color:entityColor, persistence:discPersistence});
        } else if(!fling){
            mouseDown = true;
            addDisc(mouse.x, mouse.y, {r:discRadius, color:entityColor, persistence:discPersistence});
            spawnInterval = setInterval(() => {
                if (mouseDown) addDisc(mouse.x, mouse.y, {r:discRadius, color:entityColor, persistence:discPersistence});
            }, 20); // every 100 ms
        }
    }
})
canvas.addEventListener('pointermove', e=>{
    const rect = canvas.getBoundingClientRect(); 
    mouse.x = e.clientX - rect.left; 
    mouse.y = e.clientY - rect.top;
    // drag if picked
    const heldDisc = discs.find(c=>c.dragging);
    if(heldDisc){ 
        heldDisc.pos.x = mouse.x - heldDisc.dragOffset.x; 
        heldDisc.pos.y = mouse.y - heldDisc.dragOffset.y; 
    }
})
canvas.addEventListener('pointerup', e=>{
    mouse.down=false;
    // if dragged start->release with velocity create (spawn) impulse
    const heldDiscIndex = discs.findIndex(b=>b.dragging);
    const heldSegmentIndex = segments.findIndex(s=>s.dragging);

    if(heldDiscIndex>=0){ 
        discs[heldDiscIndex].dragging = false;
    }
    if(mouse.start && !e.shiftKey && heldDiscIndex<0 && heldSegmentIndex<0 && fling){
        const dx = mouse.x - mouse.start.x, dy = mouse.y - mouse.start.y;
        if(Math.hypot(dx,dy) > 6){ // fling create
            const c = addDisc(mouse.start.x, mouse.start.y, {r:discRadius, color:entityColor, persistence:discPersistence});
            c.vel.x = 0.1*dx/dt; 
            c.vel.y = 0.1*dy/dt;
        }
    } else if(!fling){
        mouseDown = false;
        clearInterval(spawnInterval);
    }
    mouse.start = null;
});

canvas.addEventListener("mouseleave", () => {
  mouseDown = false;
  clearInterval(spawnInterval);
});

function pickDisc(x,y){
  for(let i=discs.length-1; i>=0; i--){ 
    const c=discs[i];
    const dx = c.pos.x-x;
    const dy = c.pos.y-y;
    if(dx*dx + dy*dy <= c.r2) 
        return c;
    }
  }

// default starting arrangement
////////////////////////////////////////////////////////////////////////////////////////////////
function defaultStart(){
    startPreset();

    dt = 0.02;
    dtInput.value = dt;
    dtVal.textContent = dt;

    gravity = 500;
    gravInput.value = gravity;
    gravVal.textContent = gravity;

    let numPoints = 10;
    let r = W/20;

    discRadius = W/40;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;
    addDisc(W/2, H/2, {r:discRadius, color:entityColor, persistence:discPersistence});

    discRadius = W/100;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
        addDisc(W/2 + x, H/2 + y, {r:discRadius, vel:{x:200*x/r,y:200*y/r}, color:color, persistence:discPersistence});
    }

    // add some default circles
    addSegment(W/20, H/20, W/20, H/20 + H/5, {color: entityColor});
    addSegment(W/20 + H/5, H/20, W/20 + H/5, H/20 + H/5, {color: entityColor});
    addSegment(W/20, H/20, W/20 + H/5, H/20, {color: entityColor});
    addSegment(W/20, H/20 + H/5, W/20 + H/5, H/20 + H/5, {color: entityColor});
    addDisc(W/20 + H/10, H/20 + H/10, {r:discRadius, density:1, vel:{x:0,y:W/100}, color: "#" + [200, 50, 50].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});

    addSegment(W - W/20, H - H/20, W - W/20, H - (H/20 + H/5), {color: entityColor});
    addSegment(W - (W/20 + H/5), H - H/20, W - (W/20 + H/5), H - (H/20 + H/5), {color: entityColor});
    addSegment(W - W/20, H - H/20, W - (W/20 + H/5), H - H/20, {color: entityColor});
    addSegment(W - W/20, H - (H/20 + H/5), W - (W/20 + H/5), H - (H/20 + H/5), {color: entityColor});
    addDisc(W - (W/20 + H/20), H - (H/20 + H/20), {r:discRadius, vel:{x:0,y:W/100}, color:"#" + [50, 200, 50].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});
    addDisc(W - (W/20 + H/7), H - (H/20 + H/20), {r:discRadius, vel:{x:0,y:W/100}, color:"#" + [50, 50, 200].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});
    addDisc(W - (W/20 + H/10), H - (H/20 + H/10), {r:discRadius, vel:{x:0,y:W/100}, color:"#" + [100, 50, 100].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});

    runningPreset = false;    
    preset1.classList.toggle("pressed");
    preset2.classList.toggle("pressed");
    preset3.classList.toggle("pressed");
    preset4.classList.toggle("pressed");
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
// standard preset
////////////////////////////////////////////////////////////////////////////////////////////////
function startPreset(){
    runningPreset = true;
    preset1.classList.toggle("pressed");
    preset2.classList.toggle("pressed");
    preset3.classList.toggle("pressed");
    preset4.classList.toggle("pressed");

    discs.length = 0;
    segments.length = 0;
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = `rgba(11, 18, 32, 1)`; // last number = alpha (0 transparent, 1 opaque)
    ctx.fillRect(0, 0, W, H);

    gravity = 0;
    gravInput.value = gravity;
    gravVal.textContent = gravity;

    dt = 0.01;
    dtInput.value = dt;
    dtVal.textContent = dt;

    discRadius = W/50;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;

    downforce = 0;
    downforceInput.value = downforce;
    downforceVal.textContent = downforce;

    globalRestitution = 1;
    restInput.value = globalRestitution;
    restVal.textContent = globalRestitution;

    globalFriction = 0;
    frictionInput.value = globalFriction;
    frictionVal.textContent = globalFriction;

    hideVelVector = true;
    document.getElementById('velvector').textContent = 'Velocity üöÄ';

    trail = true;
    document.getElementById('fade').textContent = 'No trail üö´';


    alphaDownscale = 100;
    alphaDownscaleInput.value = alphaDownscale;
    alphaDownscaleVal.textContent = alphaDownscale;

    discPersistence = 100;
    discPersistenceInput.value = discPersistence;
    discPersistenceVal.textContent = discPersistence;

    fill = false;
    document.getElementById('fill').textContent = 'Fill üé®';

    paused = false;
    document.getElementById('pause').textContent = 'Pause ‚è∏Ô∏è';
}

function endPreset(){
    runningPreset = false;
    discs.length = 0;
    segments.length = 0;
    
    preset1.classList.toggle("pressed");
    preset2.classList.toggle("pressed");
    preset3.classList.toggle("pressed");
    preset4.classList.toggle("pressed");
}

// tubes
////////////////////////////////////////////////////////////////////////////////////////////////
function tubes(){
    startPreset()

    fill = true;
    document.getElementById('fill').textContent = 'No Fill ü™π';

    addDisc(W/10, H/9, {r:discRadius, vel:{x:(1/16)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
    addDisc(W/10, 2*H/9, {r:discRadius, vel:{x:(1/8)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
    addDisc(W/10, 3*H/9, {r:discRadius, vel:{x:(1/4)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
    addDisc(W/10, 4*H/9, {r:discRadius, vel:{x:(1/2)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
    sleep(1500).then(() => {
        discs.length = 0;

        fill = false;
        document.getElementById('fill').textContent = 'Fill üé®';

        addDisc(W/10, 5*H/9, {r:discRadius, vel:{x:(1/16)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
        addDisc(W/10, 6*H/9, {r:discRadius, vel:{x:(1/8)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
        addDisc(W/10, 7*H/9, {r:discRadius, vel:{x:(1/4)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
        addDisc(W/10, 8*H/9, {r:discRadius, vel:{x:(1/2)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
        sleep(1500).then(() => {
            discs.length = 0;
            endPreset();
        });
    });
}


// cascade
////////////////////////////////////////////////////////////////////////////////////////////////
function cascade(){
    startPreset()

    discRadius = W/100;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;

    downforce = 1000;
    downforceInput.value = downforce;
    downforceVal.textContent = downforce;

    globalRestitution = 0.25;
    restInput.value = globalRestitution;
    restVal.textContent = globalRestitution;

    globalFriction = 0.25;
    frictionInput.value = globalFriction;
    frictionVal.textContent = globalFriction;

    discPersistence = 99;
    discPersistenceInput.value = discPersistence;
    discPersistenceVal.textContent = discPersistence;

    let numPoints = 10;
    let numCascades = 20;
    let r = W/100;

    for (let j = 0; j < numCascades; j++){
        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * 2 * Math.PI;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            centerX = W*j/numCascades;
            centerY = 0.5*H + (j/numCascades)*0.5*H*Math.cos(4*Math.PI*j/numCascades);
            color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
            addDisc(centerX + x, centerY + y, {r:discRadius, vel:{x:0.0001*(W/dt)*x,y:0.0001*(W/dt)*y}, color:entityColor, persistence:discPersistence});
        }
    }

    sleep(2000).then(() => {
        numPoints = 10;
        numCascades = 50;

        discRadius = W/200;
        discRadiusInput.value = discRadius;
        discRadiusVal.textContent = discRadius;

        discPersistence = 65;
        discPersistenceInput.value = discPersistence;
        discPersistenceVal.textContent = discPersistence;

        r = 5*W/200;
        for (let j = 0; j < numCascades; j++){
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                centerX = W - W*j/numCascades;
                centerY = H - 0.2*H - 0.1*(j/numCascades)*H*Math.sin(8*Math.PI*j/numCascades);
                color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
                addDisc(centerX + x, centerY + y, {r:discRadius, vel:{x:0.00005*(W/dt)*x,y:0.00005*(W/dt)*y}, color:entityColor, persistence:discPersistence});
            }
        }
        sleep(1500).then(() => {
            endPreset()
        });
    });
}


// vortex
////////////////////////////////////////////////////////////////////////////////////////////////
function vortex(){
    startPreset()

    dt = 0.02;
    dtInput.value = dt;
    dtVal.textContent = dt;

    discRadius = W/100;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;

    gravity = 500;
    gravInput.value = gravity;
    gravVal.textContent = gravity;

    globalRestitution = 0.5;
    restInput.value = globalRestitution;
    restVal.textContent = globalRestitution;

    discPersistence = 100;
    discPersistenceInput.value = discPersistence;
    discPersistenceVal.textContent = discPersistence;

    let numPoints = 25;
    let r = 30*W/200;

    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        centerX = W/2;
        centerY = H/2;
        color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
        addDisc(centerX + x, centerY + y, {r:discRadius, color:entityColor, persistence:discPersistence});
    }

    sleep(12000).then(() => {
        endPreset();
    });
}


// pattern
////////////////////////////////////////////////////////////////////////////////////////////////
function pattern(){
    startPreset()

    gravity = 100;
    discPersistence = 100;
    globalRestitution = 0.1;
    globalFriction = 0.1;

    dt = 0.01;
    dtInput.value = dt;
    dtVal.textContent = dt;

    discRadius = W/10;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;
    addDisc(W/2, H/2, {r:discRadius, color:entityColor, persistence:discPersistence});

    discRadius = W/1000;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;

    // hideVelVector = false;
    // document.getElementById('velvector').textContent = 'No Velocity';

    // gravity = 500;
    // gravInput.value = gravity;
    // gravVal.textContent = gravity;

    numPoints = 1000;
    // addDisc(W/10, 6*H/10, {r:discRadius, vel:{x:50,y:0}, persistence:discPersistence});
    // addDisc(W/10, 4*H/10, {r:discRadius, vel:{x:50,y:0}, persistence:discPersistence});

    for (let i = 0; i < numPoints; i++) {
        x = W/10;
        y = (i+1)/(numPoints+2)*H,
        r = Math.floor(255*(y/H))
        g = Math.floor(255*(y/H))
        b = Math.floor(255-255*(y/H))
        addDisc(x, y, {r:discRadius, vel:{x:50,y:0}, color:"#" + [r,g,b].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});
    }
    // r = W/10 + W/100;
    // numPoints = 100
    // for (let i = 0; i < numPoints; i++) {
    //     const angle = (i / numPoints) * 2 * Math.PI;
    //     const x = r * Math.cos(angle);
    //     const y = r * Math.sin(angle);
    //     centerX = W/2;
    //     centerY = H/2;
    //     color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
    //     addDisc(centerX + x, centerY + y, {r:discRadius, color:entityColor, persistence:discPersistence});
    // }
    endPreset();
}
defaultStart();

// tubes();
//vortex();
</script>
</body>
</html>