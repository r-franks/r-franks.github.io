<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Physics Tank</title>
  <style>
    html,
    body{height:100%;
         background:#0f1724;
         margin:0;
         font-family:Inter,system-ui,Arial}
    #app{display:flex;
         height:100vh}
    #canvasWrap{flex:1;
                background:#0b1220;
                display:flex;
                align-items:stretch}
    canvas{width:100%;
           height:100%;
           display:block}
    #ui{width:320px;
        background:#0f1724;
        color:#e6eef8;
        padding:14px;
        box-sizing:border-box}
    h1{font-size:16px;
       margin:4px 0 10px}
    input[type="color"] {
    border-radius: 5px;
    width: 22px;
    height: 22px;
    padding: 0;
    }
    .row{display:flex;
         gap:8px;
         margin-bottom:8px;
         align-items: center;}
    button:active {
    background: #1e2a46;           /* slightly lighter or darker */
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    transform: translateY(1px);    /* gives a ‚Äúpressed-in‚Äù feel */
    border-color: rgba(255,255,255,0.12);
    }
    button.pressed {
    background: #1e2a46;           /* slightly lighter or darker */
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    transform: translateY(1px);    /* gives a ‚Äúpressed-in‚Äù feel */
    border-color: rgba(255,255,255,0.12);
    }
    button, 
    input[type=range]{padding:8px;
                      border-radius:8px;
                      border:1px solid rgba(255,255,255,0.06);
                      background:#172034;color:inherit}
    .small{font-size:13px}
    label{font-size:12px;
          opacity:.9}
    .stat{font-family:monospace;
          font-size:13px;margin-top:8px}
    .hint{font-size:12px;
          opacity:.8;
          margin-top:6px}

    /* Keyboard-style button */
    .keyBtn {
    border-radius: 4px;                       /* sharper edges, key-like */
    background: #1a2335;                      /* a bit flatter background */
    border: 1px solid rgba(255,255,255,0.12); /* slightly brighter border */
    font-family: monospace;                   /* optional, more "key" feel */
    font-size: 14px;
    padding: 6px 6px;
    box-shadow: 0 4px 0 #0b1220;              /* "stem" under the key */
    transition: transform 0.05s, box-shadow 0.05s;
    }

    /* Press effect */
    .keyBtn:active,
    .keyBtn.pressed {
    transform: translateY(2px);               /* pushes down */
    box-shadow: 1 1 1 #0b1220;                /* stem disappears */
    background: #202c46;
    }
    /* color button button */
    .colorBtn {
    border-radius: 4px;
    background: #1a2335;
    border: 1px solid rgba(255,255,255,0.12);
    font-family: monospace;
    font-size: 14px;
    padding: 6px 6px;
    box-shadow: 0 4px 0 #0b1220;
    transition: transform 0.05s, box-shadow 0.05s,
    }

    /* Press effect */
    .colorBtn:active,
    .colorBtn.pressed {
    transform: translateY(2px);
    box-shadow: 1 1 1 #0b1220;
    background: repeating-linear-gradient(
        90deg,
        red,
        orange,
        yellow,
        green,
        cyan,
        blue,
        violet,
        red
    );
    background-size: 400%;       /* enough for color variation */
    background-repeat: repeat-x; /* tile it horizontally */
    animation: rainbowShift 8s linear infinite;
    }
    @keyframes rainbowShift {
        0%   { background-position: 0% 50%; }
        100% { background-position: 400% 50%; } /* shift by full width */
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="canvasWrap">
      <canvas id="world"></canvas>
    </div>
    <div id="ui">
    <h1 style="display: flex; justify-content: space-between; align-items: center;">
        ‚öõÔ∏è Physics Tank üêü
        <button id="copyBtn" style="background-color: #8561D7;" title="Copy to clipboard">Copy to üìã</button>
    </h1>
      <div class="row">
        <button id="fling" title="Create and fling a new disc">Fling ü§æ</button>
        <button id="entityCancel" title="Delete all discs and segments">End Objects ‚ùå</button>
        <button id="clearScreen" title="Clear canvas">Wipe All üßΩ</button>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="downforce" title="Downward gravity strength" type="range" min="0" max="2000" value="0">
        <label>Downforce: <span id="downforceVal">0</span> px/s¬≤</label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="grav" title="Strength of gravity between discs" type="range" min="0" max="2000" value="500">
        <label>Gravity: <span id="gravVal">500 px¬≥/ms¬≤</span></label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="rest" type="range" min="0" max="1" step="0.01" value="1">
        <label>Coef. of Restitution: <span id="restVal">1</span></label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="friction" type="range" min="0" max="1" step="0.01" value="0">
        <label>Friction: <span id="frictionVal">0</span></label>
      </div>

      <div class="row">
        <button id="fade" title="Discs do not leave trail">No trail üö´</button>  
        <button id="velvector" title="Hide velocity vector">No Velocity</button>
        <input type="color" title="Disc color" id="colorPicker" value="#4488ff">
        <button id="colorJiggle" title="Jiggle disc fill color" class="colorBtn">üé≤</button>  
        <input type="color" title="Velocity vector color" id="velColorPicker" value="#ffd166">
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="alpha_downscale" title="Length of disc trails" type="range" min="1" max="100" step="1" value="100">
        <label>Trail Length: <span id="alphaDownscaleVal">Infinity</span></label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="discPersistence" title="Time until discs fade away" type="range" min="1" max="100" step="1" value="100">
        <label>Disc Persistence: <span id="discPersistenceVal">Infinity</span></label>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="discRadius" type="range" min="1" max="100" step="1" value="10">
        <label>Disc Radius: <span id="discRadiusVal">20</span></label>
      </div>

      <div class="row">
        <button id="pause">Pause ‚è∏Ô∏è</button>
        <button id="step">Step üë£</button>
        <button id="fill" title="Color-fill discs">Fill üî¥</button>
      </div>

      <div style="display: flex; align-items: center; gap: 8px;">
        <input id="dt" type="range" min="0" max="0.1" step="0.001" value="0.02">
        <label>Œît: <span id="dtVal">0.02</span>s</label>
      </div>

      <div class="row">
        <button id="controls" title="More info about controls and shortcuts">About üéÆ</button>
        <button id="Preset #1" title="Start-up configuration" class="keyBtn">1</button>
        <button id="Preset #2" title="Tubes" class="keyBtn">2</button>
        <button id="Preset #3" title="Cascades" class="keyBtn">3</button>
        <button id="Preset #4" title="Vortices" class="keyBtn">4</button>
        <button id="Preset #5" title="Fun!" class="keyBtn">5</button>
      </div>
      <div class="stat" id="stats">discs: 0 | FPS: 0</div>
    </div>
  </div>

<script>
/****************************************************************
 * Mini Rigid Body Engine
 * - Shapes: Circle and Box (AABB with orientation)
 * - Integrator: Semi-implicit Euler
 * - Collision: Circle-Circle, AABB-AABB (oriented rect), Circle-AABB
 * - Resolution: Impulse-based with positional correction
 * - Simple constraints: world bounds
 ****************************************************************/

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d', { willReadFrequently: true});
const rect = canvas.getBoundingClientRect();
const dpr = window.devicePixelRatio || 1;
// let innerWidth = rect.width * dpr;
// let innerHeight = rect.height * dpr;
// let W = canvas.width;
// let H = canvas.height;
// canvas.width = W;
// canvas.height = H;

let W = canvas.width = (innerWidth - 320)*dpr; // leave room for UI
let H = canvas.height = innerHeight*dpr;

const picker = document.getElementById("colorPicker");
const velPicker = document.getElementById("velColorPicker");
let runningPreset = false;
let entityColor = "#4488ff";
let jiggleColor = false;
let velColor = "#ffd166"

// Engine 
let mouseDown = false;
let fling = false;
let gravity = 500; // px/s^2
let downforce = 0;
let globalRestitution = 1.0;
let globalFriction = 0.0;
let discRadius = 10;
let globalFadeRate = 100;
let fadeCounter = 1;
let globalFadeOut = 1;
let discPersistence = 100;
let trail = true;
let dt = 0.02;
let last = performance.now();
let paused = false;
let hideVelVector = false;
let fill = false;
let spawnInterval = null;

// Scene
const discs = [];
const segments = [];

function rand(min,max){return Math.random()*(max-min)+min}

// Vector helpers
const v = {
  add:(a,b)=>({x:a.x+b.x,y:a.y+b.y}),
  sub:(a,b)=>({x:a.x-b.x,y:a.y-b.y}),
  mul:(a,s)=>({x:a.x*s,y:a.y*s}),
  dot:(a,b)=>a.x*b.x+a.y*b.y,
  len:(a)=>Math.hypot(a.x,a.y),
  normalize:(a)=>{const L=Math.hypot(a.x,a.y)||1;return {x:a.x/L,y:a.y/L}},
}

class Disc {
    constructor(x, y, opts={}){
        this.posCurr = {x,y}; // used to sweep lines
        this.velCurr = opts.velCurr || {x:0.0, y:0.0};
        this.accCurr = opts.accCurr || {x:0.0, y:0.0};

        this.posNext = {x: this.posCurr.x, y:this.posCurr.y};
        this.velNext = {x: this.velCurr.x, y:this.velCurr.y};
        this.accNext = {x: this.accCurr.x, y:this.accCurr.y};

        this.r = opts.r ?? 1.0;
        this.r2 = this.r*this.r;

        this.color = opts.color ?? "#4488ff";
        this.persistence = opts.persistence ?? 100;
        this.startPersistence = this.persistence;

        this.density = opts.density ?? 1.0;
        this.mass = this.density * Math.PI * this.r2;
        this.invMass = 1/this.mass;

        this.dragging = opts.dragging ?? false;
    }
}

class Segment {
    constructor(x1, y1, x2, y2, opts={}){
        this.start = {x: x1, y: y1};
        this.end = {x: x2, y: y2};
        this.dx = this.end.x - this.start.x;
        this.dy = this.end.y - this.start.y;
        this.dx2 = this.dx * this.dx;
        this.dy2 = this.dy * this.dy;
        this.len2 = this.dx2 + this.dy2;
        this.color = opts.color || "#8fb7ff"
        this.dragging = opts.dragging || false;
    }
}

// Scene helpers
function addDisc(x, y, opts={}){ 
    const c = new Disc(x, y, opts); 
    discs.push(c); 
    return c;
}

function addSegment(x1, y1, x2, y2, opts={}){ 
    const s = new Segment(x1, y1, x2, y2, opts=opts); 
    segments.push(s); 
    return s;
}

function detectDiscSegmentCollision(c, s) {
    // Precompute vector from start to circle center
    const vx = c.posNext.x - s.start.x;
    const vy = c.posNext.y - s.start.y;

    // Project onto segment (normalized to [0,1])
    let t = (vx * s.dx + vy * s.dy) / s.len2; // s.len2 = dx*dx + dy*dy (precomputed)
    if (t < 0) t = 0;
    else if (t > 1) t = 1;

    // Closest point
    const px = s.start.x + t * s.dx;
    const py = s.start.y + t * s.dy;

    // Squared distance check (avoids sqrt)
    const dx = c.posNext.x - px;
    const dy = c.posNext.y - py;
    return dx*dx + dy*dy <= c.r2;
}

function resolveDiscDisc(a, b) {
    // Vector between centers
    const dx = b.posNext.x - a.posNext.x;
    const dy = b.posNext.y - a.posNext.y;

    const minDist = a.r + b.r;
    const dist2 = dx*dx + dy*dy;
    if (dist2 >= minDist * minDist) return; // no collision

    const dist = Math.sqrt(dist2) || 1e-8; // avoid division by zero
    const nx = dx / dist; // normal unit vector x
    const ny = dy / dist; // normal unit vector y
    const tx = -ny; // tangent unit vector x
    const ty =  nx; // tangent unit vector y

    const penetration = minDist - dist;
    if (penetration <= 0) return; // not colliding

    // --- 1. Positional correction ---
    const totalInvMass = a.invMass + b.invMass;
    
    if(!a.dragging && !b.dragging){
        const correction = penetration / totalInvMass;
        a.posNext.x -= nx * correction * a.invMass;
        a.posNext.y -= ny * correction * a.invMass;
        b.posNext.x += nx * correction * b.invMass;
        b.posNext.y += ny * correction * b.invMass;
    } else if(a.dragging){
        b.posNext.x += nx * penetration;
        b.posNext.y += ny * penetration;  
    } else {
        a.posNext.x -= nx * penetration;
        a.posNext.y -= ny * penetration;
    }

    // --- 2. Relative velocity ---
    const rvx = b.velNext.x - a.velNext.x;
    const rvy = b.velNext.y - a.velNext.y;
    const velAlongNormal = rvx * nx + rvy * ny;
    const velAlongTang = rvx * tx + rvy * ty;

    // If moving apart, skip
    if (velAlongNormal > 0) return;

    // --- 3. Calculate impulse scalar ---
    const j = -(1 + globalRestitution) * velAlongNormal / totalInvMass;

    // Tangential impulse
    let jt = -velAlongTang / totalInvMass;
    // Coulomb friction: clamp jt by Œº * |j|
    const maxFriction = globalFriction * Math.abs(j);
    if (Math.abs(jt) > maxFriction) {
        jt = jt > 0 ? maxFriction : -maxFriction;
    }

    // --- 4. Apply impulse ---
    const impulseX = j * nx + jt * tx;
    const impulseY = j * ny + jt * ty;

    if(!a.dragging && !b.dragging){
        a.velNext.x -= impulseX * a.invMass;
        a.velNext.y -= impulseY * a.invMass;

        b.velNext.x += impulseX * b.invMass;
        b.velNext.y += impulseY * b.invMass;
    } else if(a.dragging){
        b.velNext.x += impulseX * totalInvMass;
        b.velNext.y += impulseY * totalInvMass;
    } else {
        a.velNext.x -= impulseX * totalInvMass;
        a.velNext.y -= impulseY * totalInvMass;
    }

}

function resolveDiscSegment(c, s) {
    // Projection factor (clamped 0..1)
    const t = Math.max(0, Math.min(1, ((c.posNext.x - s.start.x) * s.dx + (c.posNext.y - s.start.y) * s.dy) / (s.dx2 + s.dy2)));

    // Closest point on segment
    const closestX = s.start.x + t * s.dx;
    const closestY = s.start.y + t * s.dy;

    // Vector from closest point to circle center
    let nx = c.posNext.x - closestX;
    let ny = c.posNext.y - closestY;
    const distSq = nx*nx + ny*ny;
    const radiusSq = c.r2;

    // If not colliding, exit
    if (distSq > radiusSq) return false;

    const dist = Math.sqrt(distSq) || 0.0001; // avoid div by 0

    // Normal vector (unit)
    nx /= dist;
    ny /= dist;
    const tx = -ny;
    const ty = nx;

    // Push circle out of wall
    const penetration = c.r - dist;
    c.posNext.x += nx * penetration;
    c.posNext.y += ny * penetration;

    // Reflect velocity: v' = v - (1 + e)*(v¬∑n) n
    const velAlongNormal = c.velNext.x * nx + c.velNext.y * ny;
    const velAlongTang = c.velNext.x * tx + c.velNext.y * ty;

    const j = -(1 + globalRestitution) * velAlongNormal;
    // Tangential impulse
    let jt = -velAlongTang;
    // Coulomb friction: clamp jt by Œº * |j|
    const maxFriction = globalFriction * Math.abs(j);
    if (Math.abs(jt) > maxFriction) {
        jt = jt > 0 ? maxFriction : -maxFriction;
    }

    // --- 4. Apply impulse ---
    const impulseX = j * nx + jt * tx;
    const impulseY = j * ny + jt * ty;

    c.velNext.x += impulseX;
    c.velNext.y += impulseY;
}

function resolveTunneledDiscSegment(c, s){
    // Projection factor (clamped 0..1)
    const t = Math.max(0, Math.min(1, ((c.posNext.x - s.start.x) * s.dx + (c.posNext.y - s.start.y) * s.dy) / (s.dx2 + s.dy2)));

    // Closest point on segment
    const closestX = s.start.x + t * s.dx;
    const closestY = s.start.y + t * s.dy;

    // Vector from closest point to circle center
    const dx = c.posNext.x - closestX;
    const dy = c.posNext.y - closestY;
    const distSq = dx*dx + dy*dy;
    const radiusSq = c.r2;

    const invDistSq = 1/(distSq || 0.0001);

    // set next pos to current pos
    // TODO: Compute intersection point, update to intersection
    c.posNext.x = c.posCurr.x;
    c.posNext.y = c.posCurr.y;

    // Reflect velocity: v' = v - (1 + e)*(v¬∑n) n
    const weightedDot = (1 + globalRestitution) * (c.velNext.x * dx + c.velNext.y * dy) * invDistSq;
    c.velNext.x = c.velNext.x - weightedDot * dx;
    c.velNext.y = c.velNext.y - weightedDot * dy;
}

function lineIntersect(A,B,C,D){
    const Ax = A.x, Ay = A.y;
    const Bx = B.x, By = B.y;
    const Cx = C.x, Cy = C.y;
    const Dx = D.x, Dy = D.y;

    return ((Dy - Ay)*(Cx - Ax) > (Cy - Ay)*(Dx - Ax)) !==
           ((Dy - By)*(Cx - Bx) > (Cy - By)*(Dx - Bx)) &&
           ((Cy - Ay)*(Bx - Ax) > (By - Ay)*(Cx - Ax)) !==
           ((Dy - Ay)*(Bx - Ax) > (By - Ay)*(Dx - Ax));
}

function distancePointToSegment(p, s) {
    const seg_start_to_c = {x: p.x - s.start.x, y: p.y - s.start.y};
    const AB = {x: s.dx, y: s.dy};

    const s2 = s.dx2 + s.dy2;
    if (s2 === 0) {
        // A and B are the same point
        return Math.hypot(seg_start_to_c.x, seg_start_to_c.y);
    }

    const t = (seg_start_to_c.x * s.dx + seg_start_to_c.y * s.dy) / s2;

    let closest;
    if (t < 0) {
        closest = s.start;
    } else if (t > 1) {
        closest = s.end;
    } else {
        closest = {x: s.start.x + t * s.dx, y: s.start.y + t * s.dy};
    }

    const distVector = {x: p.x - closest.x, y: p.y - closest.y};
    return Math.hypot(distVector.x, distVector.y);
}


// World bounds collision
function worldBounds(b){
    if(b.posNext.x - b.r < 0){
        b.posNext.x = b.r; 

        const j = -(1 + globalRestitution) * b.velNext.x;
        let jt = -b.velNext.y;
        const maxFriction = globalFriction * Math.abs(j);
        if (Math.abs(jt) > maxFriction) {
            jt = jt > 0 ? maxFriction : -maxFriction;
        }
        b.velNext.x += j;
        b.velNext.y += jt;
    }
    if(b.posNext.x + b.r > W){
        b.posNext.x = W - b.r;

        const j = -(1 + globalRestitution) * b.velNext.x;
        let jt = -b.velNext.y;
        const maxFriction = globalFriction * Math.abs(j);
        if (Math.abs(jt) > maxFriction) {
            jt = jt > 0 ? maxFriction : -maxFriction;
        }
        b.velNext.x += j;
        b.velNext.y += jt;
    }
    if(b.posNext.y - b.r < 0){
        b.posNext.y = b.r; 

        const j = -(1 + globalRestitution) * b.velNext.y;
        let jt = -b.velNext.x;
        const maxFriction = globalFriction * Math.abs(j);
        if (Math.abs(jt) > maxFriction) {
            jt = jt > 0 ? maxFriction : -maxFriction;
        }
        b.velNext.y += j;
        b.velNext.x += jt;
    }
    if(b.posNext.y + b.r > H){ 
        b.posNext.y = H - b.r;

        const j = -(1 + globalRestitution) * b.velNext.y;
        let jt = -b.velNext.x;
        const maxFriction = globalFriction * Math.abs(j);
        if (Math.abs(jt) > maxFriction) {
            jt = jt > 0 ? maxFriction : -maxFriction;
        }
        b.velNext.y += j;
        b.velNext.x += jt;
    }
}

// Main step
function step(){  
    // update persistence value  
    for (let i = discs.length - 1; i >= 0; i--) {
        const c = discs[i];
        if(!c.dragging){
            if (c.persistence < 100){
                c.persistence -= globalFadeOut;
            }
            if (c.persistence <= 0) {
                discs.splice(i, 1);
            }
        }
    }

    // correct next position (apply boundaries)
    ///////////////////////////////////////////
    // handle discs that tunnel through segments
    const discSegmentTunneledPairs = [];
    for(let i=0; i<discs.length; i++){
        let closestTunneledSegIdx = -1;
        let lowestTunneledSegDist = 1000000;
        for(let j=0; j<segments.length; j++){
            const c=discs[i];
            const s=segments[j];
            if(lineIntersect(c.posCurr, c.posNext, s.start, s.end)){
                segDist = distancePointToSegment(c.posCurr, s);
                if(segDist <= lowestTunneledSegDist && !c.dragging){
                    closestTunneledSegIdx = j;
                    lowestTunneledSegDist = segDist;
                }
            }
        }
        if(closestTunneledSegIdx >= 0){
            discSegmentTunneledPairs.push({c: discs[i], s: segments[closestTunneledSegIdx]});
        }
    }
    for(const pair of discSegmentTunneledPairs){
        resolveTunneledDiscSegment(pair.c, pair.s);
    }

    // handle circles colliding with segments
    const discSegmentCollisionPairs = [];
    for(let i=0; i<discs.length; i++){
        for(let j=0; j<segments.length; j++){
            const c=discs[i];
            const s=segments[j];
            if(detectDiscSegmentCollision(c,s)){
                discSegmentCollisionPairs.push({c, s});
            }
        }
    }
    // resolve
    for(const pair of discSegmentCollisionPairs){
        resolveDiscSegment(pair.c, pair.s);
    }

    // disc disc collisions
    // resolve disc-disc collisions after handling segment-disc collisions
    //  - don't want discs colliding with each other by tunneling through segments
    for(let i=0; i<discs.length; i++){
        for(let j=i+1; j<discs.length; j++){
            const a=discs[i];
            const b=discs[j];
            resolveDiscDisc(a, b);
        }
    }

    // check again for tunneling
    // - resolveDiscDisc can reposition discs
    // - we want to avoid cases where discs are repositions through a segment
    discSegmentTunneledPairs.length = 0;
    for(let i=0; i<discs.length; i++){
        let closestTunneledSegIdx = -1;
        let lowestTunneledSegDist = 1000000;
        for(let j=0; j<segments.length; j++){
            const c=discs[i];
            const s=segments[j];
            if(lineIntersect(c.posCurr, c.posNext, s.start, s.end)){
                segDist = distancePointToSegment(c.posCurr, s);
                if(segDist <= lowestTunneledSegDist && !c.dragging){
                    closestTunneledSegIdx = j;
                    lowestTunneledSegDist = segDist;
                }
            }
        }
        if(closestTunneledSegIdx >= 0){
            discSegmentTunneledPairs.push({c: discs[i], s: segments[closestTunneledSegIdx]});
        }
    }
    for(const pair of discSegmentTunneledPairs){
        resolveTunneledDiscSegment(pair.c, pair.s);
    }

    // world bounds
    for(const c of discs){
        worldBounds(c);
    }

    // integrate
    ///////////////////////////////////////

    // update position (velocity verlet)
    // pos_old = pos
    // pos = pos + vel*dt + 0.5*acc_new*dt^2
    // x(t+dt) = x(t) + v(t)dt + 0.5*a(t)*dt^2
    for (let i = discs.length - 1; i >= 0; i--) {
        const c = discs[i];
        if(!c.dragging){
            // posCurr becomes posNext
            c.posCurr.x = c.posNext.x;
            c.posCurr.y = c.posNext.y;

            // velCurr becomes velNext
            c.velCurr.x = c.velNext.x;
            c.velCurr.y = c.velNext.y;

            // accCurr becomes accNext
            c.accCurr.x = c.accNext.x;
            c.accCurr.y = c.accNext.y;

            // compute new next position (posNext)
            c.posNext.x = c.posCurr.x + c.velCurr.x * dt + 0.5 * c.accCurr.x * dt * dt;
            c.posNext.y = c.posCurr.y + c.velCurr.y * dt + 0.5 * c.accCurr.y * dt * dt;

            // reset accNext, velNext
            // (must be updated to reflect new posNext)
            c.velNext = {x: 0, y:0};
            c.accNext = {x: 0, y:0};
        }
    }

    // update acceleration
    // downforce to accNext
    for(const c of discs){
        if(!c.dragging){
            c.accNext.y += downforce;
        }
    }

    // update acceleration
    // intra disc gravity at next positions
    for(let i=0; i<discs.length; i++){
        for(let j=i+1; j<discs.length; j++){
            const a=discs[i];
            const b=discs[j];
            const dx = a.posNext.x - b.posNext.x;
            const dy = a.posNext.y - b.posNext.y;
            const r2 = dx*dx + dy*dy;

            const minDist = a.r + b.r;
            const minDist2 = minDist*minDist;

            let r3;
            if(minDist2 < r2){
                r3 = r2 * Math.sqrt(r2);
            } else {
                r3 = minDist2 * minDist;
            }
            const invr3 = 1/r3;

            const gma = gravity*a.mass;
            const gmb = gravity*b.mass

            if(!a.dragging){
                a.accNext.x -= gmb*dx*invr3;
                a.accNext.y -= gmb*dy*invr3;
            }

            if(!b.dragging){
                b.accNext.x += gma*dx*invr3;
                b.accNext.y += gma*dy*invr3;
            }
        }
    }

    // update velocity (velocity verlet)
    // vel = vel + 0.5*(acc + acc_new)*dt
    // x(t+dt) = x(t) + v(t)dt + 0.5*a(t)*dt^2
    for (let i = discs.length - 1; i >= 0; i--) {
        const c = discs[i];
        if(!c.dragging){
            c.velNext.x = c.velCurr.x + 0.5*(c.accCurr.x + c.accNext.x)*dt;
            c.velNext.y = c.velCurr.y + 0.5*(c.accCurr.y + c.accNext.y)*dt;
        }
    }
}

// tracks when we are starting to fade-out trails
let fade_trigger = false;

// Rendering
function draw(){
    if(trail){
        // if we are letting circle trails fade out...

        // draw canvas as original color if this is the first frame 
        // that we have fade outs
        if(!fade_trigger){
            fade_trigger = true;
            ctx.clearRect(0, 0, W, H);
        }
        if(globalFadeRate != 100){
            // handle sub-point fading
            trueFadeOut = 0.1 * (100 - globalFadeRate);
            if (trueFadeOut > 1){
                // if trueFadeOut above 1, reduce alpha every frame
                fadeFreq = 1;
            } else {
                // if trueFadeOut below 1, don't reduce alpha every frame
                fadeFreq = 1/trueFadeOut;
                trueFadeOut = 1;
            }

            if (fadeCounter % fadeFreq == 0){
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    data[i + 3] = Math.max(data[i + 3] - trueFadeOut, 0); // scale alpha
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.putImageData(imageData, 0, 0);

                // update fadeCounter
                fadeCounter = 1
            } else {
                fadeCounter += 1;
            }
        }
    } else {
        // render canvas with no trails by clearing it completely
        fade_trigger = false;
        alpha = 1.0;
        ctx.clearRect(0, 0, W, H);

        ctx.save();

        // background grid
        ctx.globalAlpha = 0.1;
        ctx.strokeStyle = '#fff';
        for(let x=0;x<W;x+=40){
            ctx.beginPath();
            ctx.moveTo(x,0);
            ctx.lineTo(x,H);
            ctx.stroke();
        }

        for(let y=0;y<H;y+=40){
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(W,y);
            ctx.stroke();
        }
        ctx.restore();
    }

    for(const c of discs){
        fractionFaded = c.persistence/c.startPersistence;
        fillAlpha = Math.round(50*fractionFaded).toString().padStart(2, "0");
        strokeAlpha = Math.round(99*fractionFaded).toString().padStart(2, "0");
        if(fill){
            ctx.fillStyle = c.color + fillAlpha;
        } else {
            ctx.fillStyle = `rgba(11, 18, 32, 1)`;
        }
        ctx.strokeStyle = c.color + strokeAlpha;

        ctx.beginPath();
        ctx.arc(c.posCurr.x, c.posCurr.y, c.r, 0, Math.PI*2);
        ctx.fill();
        ctx.lineWidth=1.5;
        ctx.stroke();

        // velocity arrow
        if(!hideVelVector){
            ctx.beginPath();
            ctx.moveTo(c.posCurr.x, c.posCurr.y);
            ctx.lineTo(c.posCurr.x + c.velCurr.x*0.08, c.posCurr.y + c.velCurr.y*0.08);
            ctx.strokeStyle=velColor;
            ctx.stroke();
        }
    }

    for(const s of segments){
        ctx.beginPath();
        ctx.moveTo(s.start.x, s.start.y);   // start point
        ctx.lineTo(s.end.x, s.end.y);   // end point
        ctx.strokeStyle=s.color;
        ctx.stroke();
        }
    }

// Loop
let fps = 60;
function loop(now){
  requestAnimationFrame(loop);
  const elapsed = (now - last) / 1000;
  last = now;
  if(!paused){
    step();
  }
  draw();
  // stats
  if(elapsed > 0){
    fps = (59/60)*fps + (1/60)*1/Math.max(elapsed,1e-6);
  } else {
    fps = 60;
  }
  document.getElementById('stats').textContent = `discs: ${discs.length} | walls: ${segments.length} | FPS: ${Math.round(fps)}`;
}

requestAnimationFrame(loop);

// UI hooks
// Resize handling
function resize(){
    W = canvas.width = (innerWidth - 320)*dpr; 
    H = canvas.height = innerHeight*dpr; }
addEventListener('resize', resize);

picker.addEventListener("input", (event) => {
    const color = event.target.value; // hex string like "#1e90ff"
    entityColor = color;
});
velPicker.addEventListener("input", (event) => {
    const color = event.target.value; // hex string like "#1e90ff"
    velColor = color;
});
document.getElementById('fling').onclick = function(){ fling = !fling; this.textContent = fling ? 'Pour ü´ó' : 'Fling ü§æ'; this.title = fling ? 'Continuously create discs' : 'Create and fling a new disc';};
document.getElementById('velvector').onclick = function(){ hideVelVector = !hideVelVector; this.textContent = hideVelVector ? 'Velocity üöÄ' : 'No Velocity'; this.title = hideVelVector ? 'Draw velocity vector' : 'Hide velocity vector';};
document.getElementById('entityCancel').onclick = ()=>{ discs.length = 0; segments.length = 0; };
document.getElementById('clearScreen').onclick = ()=>{ ctx.clearRect(0, 0, W, H); };
document.getElementById('copyBtn').addEventListener('click', async () => {
    try {
        const blob = await new Promise(res => canvas.toBlob(res));
        await navigator.clipboard.write([
            new ClipboardItem({ 'image/png': blob })
        ]);
        alert('Canvas image copied to clipboard!');
    } catch (err) {
        console.error('Failed to copy image:', err);
    }
});
document.getElementById('controls').addEventListener('click', async () => {
    alert('1. In "Fling" mode, click+drag elsewhere to create a moving disc\n2. In "Pour" mode, hold mouse down to continuously add discs\n3. Shift+click to spawn disc without velocity\n4. Click+drag disc to move it\n5. Click right mouse and drag to draw walls\n6. Backspace or "End objects" to delete all entities\n7. Tap keys 1-5 or press numbered buttons to activate presets');
});

preset1 = document.getElementById('Preset #1')
preset2 = document.getElementById('Preset #2')
preset3 = document.getElementById('Preset #3')
preset4 = document.getElementById('Preset #4')
preset5 = document.getElementById('Preset #5')
colorJiggle = document.getElementById('colorJiggle')

preset1.onclick = ()=>{ if(!runningPreset) defaultStart() };
preset2.onclick = ()=>{ if(!runningPreset) tubes() };
preset3.onclick = ()=>{ if(!runningPreset) cascade() };
preset4.onclick = ()=>{ if(!runningPreset) vortex() };
preset5.onclick = ()=>{ if(!runningPreset) pattern() };
colorJiggle.onclick = ()=>{ colorJiggle.classList.toggle("pressed"); jiggleColor=!jiggleColor; };

document.getElementById('pause').onclick = function(){ paused = !paused; this.textContent = paused ? 'Play ‚ñ∂Ô∏è' : 'Pause ‚è∏Ô∏è'; };
document.getElementById('step').onclick = ()=>{ if(paused) step(); };
document.getElementById('fill').onclick = function(){ fill = !fill; this.textContent = fill ? 'No Fill ‚≠ï' : 'Fill üî¥'; this.title = fill ? 'Draw disc shells only' : 'Color-fill discs';};

const gravInput = document.getElementById('grav'); const gravVal = document.getElementById('gravVal');
gravInput.oninput = ()=>{ gravity = Number(gravInput.value); gravVal.textContent = gravity };

const downforceInput = document.getElementById('downforce'); const downforceVal = document.getElementById('downforceVal');
downforceInput.oninput = ()=>{ downforce = Number(downforceInput.value); downforceVal.textContent = downforce };

const restInput = document.getElementById('rest'); const restVal = document.getElementById('restVal');
restInput.oninput = ()=>{ globalRestitution = Number(restInput.value); restVal.textContent = globalRestitution };

const frictionInput = document.getElementById('friction'); const frictionVal = document.getElementById('frictionVal');
frictionInput.oninput = ()=>{ globalFriction = Number(frictionInput.value); frictionVal.textContent = globalFriction };

const dtInput = document.getElementById('dt'); const dtVal = document.getElementById('dtVal');
dtInput.oninput = ()=>{ dt = Number(dtInput.value); dtVal.textContent = dt };

const alphaDownscaleInput = document.getElementById('alpha_downscale'); const alphaDownscaleVal = document.getElementById('alphaDownscaleVal');
alphaDownscaleInput.oninput = ()=>{ globalFadeRate = Number(alphaDownscaleInput.value); alphaDownscaleVal.textContent = globalFadeRate == 100 ? 'Infinity' : globalFadeRate};
document.getElementById('fade').onclick = function(){ trail = !trail; this.textContent = trail ? 'No trail üö´' : 'Trail üêå'; this.title =  trail ? 'Discs do not leave trails' : 'Discs leave trails';};

const discPersistenceInput = document.getElementById('discPersistence'); const discPersistenceVal = document.getElementById('discPersistenceVal');
discPersistenceInput.oninput = ()=>{ discPersistence = Number(discPersistenceInput.value); discPersistenceVal.textContent = discPersistence == 100 ? 'Infinity' : discPersistence};

const discRadiusInput = document.getElementById('discRadius'); const discRadiusVal = document.getElementById('discRadiusVal');
discRadiusInput.oninput = ()=>{ discRadius = Number(discRadiusInput.value); discRadiusVal.textContent = discRadius };

// Mouse interactions: spawn, drag
canvas.addEventListener('contextmenu', e => e.preventDefault());

let mouse = {x:0,y:0,down:false,start:null,btn:0};

// backspace logic
document.addEventListener('keydown', (e) => {
  if (e.key === 'Backspace') {
    discs.length = 0;
    segments.length = 0;
  }
  else if (e.key == '1'){
    if(!runningPreset) defaultStart();
  } else if (e.key == '2'){
    if(!runningPreset) tubes();
  } else if (e.key == '3'){
    if(!runningPreset) cascade();
  } else if (e.key == '4') {
    if(!runningPreset) vortex();
  } else if (e.key == '5') {
    if(!runningPreset) pattern();
  }
});

// segment addition logic
canvas.addEventListener('pointerdown', e=>{
    if(e.button == 2){
        s = addSegment(mouse.x, mouse.y, mouse.x, mouse.y, opts={dragging: true, color: entityColor});
    }
})
canvas.addEventListener('pointermove', e=>{
    const rect = canvas.getBoundingClientRect(); 
    mouse.x = (e.clientX - rect.left)*dpr; 
    mouse.y = (e.clientY - rect.top)*dpr;    
    const held_segment = segments.find(s=>s.dragging);
    if(held_segment){
        held_segment.end.x = mouse.x;
        held_segment.end.y = mouse.y;
        held_segment.dx = held_segment.end.x - held_segment.start.x;
        held_segment.dy = held_segment.end.y - held_segment.start.y;
        held_segment.dx2 = held_segment.dx * held_segment.dx;
        held_segment.dy2 = held_segment.dy * held_segment.dy;
        held_segment.len2 = held_segment.dx2 + held_segment.dy2;
    }
})
canvas.addEventListener('pointerup', e=>{
    mouse.down=false;
    const heldSegmentIndex = segments.findIndex(s=>s.dragging);
    if(heldSegmentIndex>=0){ 
        segments[heldSegmentIndex].dragging = false;
    }
});

// disc addition logic
canvas.addEventListener('pointerdown', e=>{
    // left mouse button
    if(e.button == 0){
        const rect = canvas.getBoundingClientRect();
        mouse.x = (e.clientX - rect.left)*dpr; 
        mouse.y = (e.clientY - rect.top)*dpr; 
        mouse.down=true; 
        mouse.btn=e.button; 
        mouse.start = {x:mouse.x,y:mouse.y};
        // pick body
        const pick = pickDisc(mouse.x, mouse.y);
        if(pick){ 
            pick.dragging = true; 
            pick.dragOffset = {x: mouse.x - pick.posCurr.x, y: mouse.y - pick.posCurr.y}; 
        }
        else if(e.shiftKey){ 
            addDisc(mouse.x, mouse.y, {r:discRadius, color:getEntityColor(), persistence:discPersistence});
        } else if(!fling){
            mouseDown = true;
            addDisc(mouse.x, mouse.y, {r:discRadius, color:getEntityColor(), persistence:discPersistence});
            spawnInterval = setInterval(() => {
                if (mouseDown) addDisc(mouse.x +  rand(-1, 1), mouse.y +  rand(-1, 1), {r:discRadius, color:getEntityColor(), persistence:discPersistence});
            }, 20); // every 100 ms
        }
    }
})
canvas.addEventListener('pointermove', e=>{
    const rect = canvas.getBoundingClientRect(); 
    mouse.x = (e.clientX - rect.left)*dpr; 
    mouse.y = (e.clientY - rect.top)*dpr;
    // drag if picked
    const heldDisc = discs.find(c=>c.dragging);
    if(heldDisc && heldDisc.dragOffset){ 
        heldDisc.posCurr.x = mouse.x - heldDisc.dragOffset.x; 
        heldDisc.posCurr.y = mouse.y - heldDisc.dragOffset.y;
        heldDisc.posNext.x = heldDisc.posCurr.x;
        heldDisc.posNext.y = heldDisc.posCurr.y;
    }
})
canvas.addEventListener('pointerup', e=>{
    mouse.down=false;
    // if dragged start->release with velocity create (spawn) impulse
    const heldDiscIndex = discs.findIndex(b=>b.dragging);
    const heldSegmentIndex = segments.findIndex(s=>s.dragging);

    if(heldDiscIndex>=0){ 
        discs[heldDiscIndex].dragging = false;
    }
    if(mouse.start && !e.shiftKey && heldDiscIndex<0 && heldSegmentIndex<0 && fling){
        const dx = mouse.x - mouse.start.x;
        const dy = mouse.y - mouse.start.y;
        if(Math.hypot(dx, dy) > 6){ // fling create
            const c = addDisc(mouse.start.x, mouse.start.y, {r:discRadius, color:entityColor, persistence:discPersistence});
            c.velCurr.x = 0.1*dx/dt; 
            c.velCurr.y = 0.1*dy/dt;
            c.velNext.x = 0.1*dx/dt; 
            c.velNext.y = 0.1*dy/dt;
        }
    } else if(!fling){
        mouseDown = false;
        clearInterval(spawnInterval);
    }
    mouse.start = null;
});

canvas.addEventListener("mouseleave", () => {
  mouseDown = false;
  clearInterval(spawnInterval);
});

function pickDisc(x,y){
  for(let i=discs.length-1; i>=0; i--){ 
    const c=discs[i];
    const dx = c.posCurr.x-x;
    const dy = c.posCurr.y-y;
    if(dx*dx + dy*dy <= c.r2) 
        return c;
    }
  }


// get entity color
////////////////////////////////////////////////////////////////////////////////////////////////
function getEntityColor(){
    if(jiggleColor){
        hueJitter = 50;
        satJitter = 0.2;
        lightJitter = 0.1;

        // Convert hex ‚Üí RGB
        let r = parseInt(entityColor.slice(1, 3), 16) / 255;
        let g = parseInt(entityColor.slice(3, 5), 16) / 255;
        let b = parseInt(entityColor.slice(5, 7), 16) / 255;

        // RGB ‚Üí HSL
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        // Apply controlled random perturbations
        h = (h + (Math.random() * 2 - 1) * hueJitter / 360) % 1;
        s = Math.min(1, Math.max(0, s + (Math.random() * 2 - 1) * satJitter));
        l = Math.min(1, Math.max(0, l + (Math.random() * 2 - 1) * lightJitter));

        // HSL ‚Üí RGB
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        let r2, g2, b2;
        if (s === 0) {
            r2 = g2 = b2 = l; // gray
        } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r2 = hue2rgb(p, q, h + 1/3);
            g2 = hue2rgb(p, q, h);
            b2 = hue2rgb(p, q, h - 1/3);
        }

        // Convert back to hex
        const toHex = x => Math.round(x * 255).toString(16).padStart(2, '0');
        return `#${toHex(r2)}${toHex(g2)}${toHex(b2)}`;
    }else{
        return entityColor;
    }

}


// default starting arrangement
////////////////////////////////////////////////////////////////////////////////////////////////
function defaultStart(){
    startPreset();

    dt = 0.02;
    dtInput.value = dt;
    dtVal.textContent = dt;

    gravity = 500;
    gravInput.value = gravity;
    gravVal.textContent = gravity;

    let numPoints = 10;
    let r = W/20;

    discRadius = W/40;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;
    addDisc(W/2, H/2, {r:discRadius, color:entityColor, persistence:discPersistence});

    discRadius = W/100;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
        addDisc(W/2 + x, H/2 + y, {r:discRadius, velCurr:{x:200*x/r,y:200*y/r}, color:color, persistence:discPersistence});
    }

    // add some default circles
    addSegment(W/20, H/20, W/20, H/20 + H/5, {color: entityColor});
    addSegment(W/20 + H/5, H/20, W/20 + H/5, H/20 + H/5, {color: entityColor});
    addSegment(W/20, H/20, W/20 + H/5, H/20, {color: entityColor});
    addSegment(W/20, H/20 + H/5, W/20 + H/5, H/20 + H/5, {color: entityColor});
    addDisc(W/20 + H/10, H/20 + H/10, {r:discRadius, density:1, velCurr:{x:0,y:W/100}, color: "#" + [200, 50, 50].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});

    addSegment(W - W/20, H - H/20, W - W/20, H - (H/20 + H/5), {color: entityColor});
    addSegment(W - (W/20 + H/5), H - H/20, W - (W/20 + H/5), H - (H/20 + H/5), {color: entityColor});
    addSegment(W - W/20, H - H/20, W - (W/20 + H/5), H - H/20, {color: entityColor});
    addSegment(W - W/20, H - (H/20 + H/5), W - (W/20 + H/5), H - (H/20 + H/5), {color: entityColor});
    addDisc(W - (W/20 + H/20), H - (H/20 + H/20), {r:discRadius, velCurr:{x:0,y:W/100}, color:"#" + [50, 200, 50].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});
    addDisc(W - (W/20 + H/7), H - (H/20 + H/20), {r:discRadius, velCurr:{x:0,y:W/100}, color:"#" + [50, 50, 200].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});
    addDisc(W - (W/20 + H/10), H - (H/20 + H/10), {r:discRadius, velCurr:{x:0,y:W/100}, color:"#" + [100, 50, 100].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});

    runningPreset = false;    
    preset1.classList.toggle("pressed");
    preset2.classList.toggle("pressed");
    preset3.classList.toggle("pressed");
    preset4.classList.toggle("pressed");
    preset5.classList.toggle("pressed");
}


function runAfterFrames(frames, callback) {
  function step() {
    if (--frames <= 0) {
      callback();
    } else {
      requestAnimationFrame(step);
    }
  }
  requestAnimationFrame(step);
}
// standard preset
////////////////////////////////////////////////////////////////////////////////////////////////
function startPreset(){
    runningPreset = true;
    preset1.classList.toggle("pressed");
    preset2.classList.toggle("pressed");
    preset3.classList.toggle("pressed");
    preset4.classList.toggle("pressed");
    preset5.classList.toggle("pressed");

    discs.length = 0;
    segments.length = 0;
    ctx.clearRect(0, 0, W, H);
    // ctx.fillStyle = `rgba(11, 18, 32, 1)`; // last number = alpha (0 transparent, 1 opaque)
    // ctx.fillRect(0, 0, W, H);

    gravity = 0;
    gravInput.value = gravity;
    gravVal.textContent = gravity;

    dt = 0.01;
    dtInput.value = dt;
    dtVal.textContent = dt;

    discRadius = W/50;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;

    downforce = 0;
    downforceInput.value = downforce;
    downforceVal.textContent = downforce;

    globalRestitution = 1;
    restInput.value = globalRestitution;
    restVal.textContent = globalRestitution;

    globalFriction = 0;
    frictionInput.value = globalFriction;
    frictionVal.textContent = globalFriction;

    hideVelVector = true;
    document.getElementById('velvector').textContent = 'Velocity üöÄ';

    trail = true;
    document.getElementById('fade').textContent = 'No trail üö´';


    globalFadeRate = 100;
    alphaDownscaleInput.value = globalFadeRate;
    alphaDownscaleVal.textContent = globalFadeRate;

    discPersistence = 100;
    discPersistenceInput.value = discPersistence;
    discPersistenceVal.textContent = discPersistence;

    fill = false;
    document.getElementById('fill').textContent = 'Fill üî¥';

    paused = false;
    document.getElementById('pause').textContent = 'Pause ‚è∏Ô∏è';
}

function endPreset(){
    runningPreset = false;
    discs.length = 0;
    segments.length = 0;
    
    preset1.classList.toggle("pressed");
    preset2.classList.toggle("pressed");
    preset3.classList.toggle("pressed");
    preset4.classList.toggle("pressed");
    preset5.classList.toggle("pressed");
}

// tubes
////////////////////////////////////////////////////////////////////////////////////////////////
function tubes(){
    startPreset()

    fill = true;
    document.getElementById('fill').textContent = 'No Fill ‚≠ï';

    addDisc(W/10, H/9, {r:discRadius, velCurr:{x:(1/16)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
    addDisc(W/10, 2*H/9, {r:discRadius, velCurr:{x:(1/8)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
    addDisc(W/10, 3*H/9, {r:discRadius, velCurr:{x:(1/4)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
    addDisc(W/10, 4*H/9, {r:discRadius, velCurr:{x:(1/2)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
   
    runAfterFrames(100, () => {
        discs.length = 0;

        fill = false;
        document.getElementById('fill').textContent = 'Fill üî¥';

        addDisc(W/10, 5*H/9, {r:discRadius, velCurr:{x:(1/16)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
        addDisc(W/10, 6*H/9, {r:discRadius, velCurr:{x:(1/8)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
        addDisc(W/10, 7*H/9, {r:discRadius, velCurr:{x:(1/4)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});
        addDisc(W/10, 8*H/9, {r:discRadius, velCurr:{x:(1/2)*(W/dt)/60, y:0}, color:entityColor, persistence:discPersistence});

        runAfterFrames(100, endPreset);
    });
}


// cascade
////////////////////////////////////////////////////////////////////////////////////////////////
function cascade(){
    startPreset()

    discRadius = W/100;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;

    downforce = 1000;
    downforceInput.value = downforce;
    downforceVal.textContent = downforce;

    globalRestitution = 0.25;
    restInput.value = globalRestitution;
    restVal.textContent = globalRestitution;

    globalFriction = 0.25;
    frictionInput.value = globalFriction;
    frictionVal.textContent = globalFriction;

    discPersistence = 99;
    discPersistenceInput.value = discPersistence;
    discPersistenceVal.textContent = discPersistence;

    let numPoints = 20;
    let numCascades = 20;
    let r = W/100;

    for (let j = 0; j < numCascades; j++){
        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * 2 * Math.PI;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            ratio = 0.25 + 0.5*(j + 1)/(numCascades + 1)
            centerX = W*ratio;
            centerY = 0.5*H + ratio*0.5*H*Math.cos(4*Math.PI*ratio);
            color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
            addDisc(centerX + x, centerY + y, {r:discRadius, velCurr:{x:0.0001*(W/dt)*x,y:0.0001*(W/dt)*y}, color:entityColor, persistence:discPersistence});
        }
    }

    runAfterFrames(100, () => {
        numPoints = 10;
        numCascades = 50;

        discRadius = W/200;
        discRadiusInput.value = discRadius;
        discRadiusVal.textContent = discRadius;

        r = 5*W/200;
        for (let j = 0; j < numCascades; j++){
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                ratio = 0.25 + 0.5*(j + 1)/(numCascades + 1);
                centerX = W*ratio;
                centerY = H - 0.2*H - 0.1*ratio*H*Math.sin(8*Math.PI*ratio);
                color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
                addDisc(centerX + x, centerY + y, {r:discRadius, velCurr:{x:0.00005*(W/dt)*x,y:0.00005*(W/dt)*y}, color:entityColor, persistence:discPersistence});
            }
        }

        runAfterFrames(100, endPreset);
    });
}


// vortex
////////////////////////////////////////////////////////////////////////////////////////////////
function vortex(){
    startPreset()

    dt = 0.02;
    dtInput.value = dt;
    dtVal.textContent = dt;

    gravity = 500;
    gravInput.value = gravity;
    gravVal.textContent = gravity;

    globalRestitution = 0.1;
    restInput.value = globalRestitution;
    restVal.textContent = globalRestitution;

    globalFriction = 0.1;
    frictionInput.value = globalFriction;
    frictionVal.textContent = globalFriction;

    discPersistence = 100;
    discPersistenceInput.value = discPersistence;
    discPersistenceVal.textContent = discPersistence;

    let numPoints = 25;
    let r = 30*W/200;

    discRadius = r/10;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;

    centerX = W/2;
    centerY = H/2;
    addDisc(centerX, centerY, {r:discRadius, color:entityColor, persistence:discPersistence, dragging:true});

    discRadius = W/200;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        color = "#" + [Math.abs(Math.round(255*x/r)), Math.abs(Math.round(0.5*255*(x+y)/r)), Math.abs(Math.round(0.5*255*(x-y)/r))].map(x => x.toString(16).padStart(2, "0")).join("");
        addDisc(centerX + x, centerY + y, {r:discRadius, color:entityColor, persistence:discPersistence});
    }

    // runAfterFrames(400, endPreset);
    runningPreset = false;    
    preset1.classList.toggle("pressed");
    preset2.classList.toggle("pressed");
    preset3.classList.toggle("pressed");
    preset4.classList.toggle("pressed");
    preset5.classList.toggle("pressed");
}


// pattern
////////////////////////////////////////////////////////////////////////////////////////////////
function pattern(){
    startPreset()

    dt = 0.01;
    dtInput.value = dt;
    dtVal.textContent = dt;

    globalRestitution = 0.8;
    restInput.value = globalRestitution;
    restVal.textContent = globalRestitution;

    globalFriction = 0.25;
    frictionInput.value = globalFriction;
    frictionVal.textContent = globalFriction;

    gravity = 1000;
    gravInput.value = gravity;
    gravVal.textContent = gravity;

    discRadius = W/10;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;
    addDisc(W/2, H/2, {r:discRadius, color:entityColor, persistence:discPersistence, dragging:true});

    discRadius = W/1000;
    discRadiusInput.value = discRadius;
    discRadiusVal.textContent = discRadius;

    numPoints = 500;
    for (let i = 0; i < numPoints; i++) {
        x = W/10;
        y = (i+1)/(numPoints+2)*H,
        r = Math.floor(255*(y/H))
        g = Math.floor(255*(y/H))
        b = Math.floor(255-255*(y/H))
        addDisc(x, y, {r:discRadius, velCurr:{x:(W/dt)/2000,y:0}, color:"#" + [r,g,b].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});
    }
    for (let i = 0; i < numPoints; i++) {
        x = 9*W/10;
        y = (i+1)/(numPoints+2)*H,
        r = Math.floor(255*(y/H))
        g = Math.floor(255 - 255*(y/H))
        b = Math.floor(255*(y/H))
        addDisc(x, y, {r:discRadius, velCurr:{x:-(W/dt)/2000,y:0}, color:"#" + [r,g,b].map(x => x.toString(16).padStart(2, "0")).join(""), persistence:discPersistence});
    }
    runningPreset = false;    
    preset1.classList.toggle("pressed");
    preset2.classList.toggle("pressed");
    preset3.classList.toggle("pressed");
    preset4.classList.toggle("pressed");
    preset5.classList.toggle("pressed");
}

// Handle global paste (Ctrl+V anywhere)
document.addEventListener('paste', async (e) => {
  const items = e.clipboardData?.items;
  if (!items) return;

  for (const item of items) {
    if (item.type.startsWith('image/')) {
      const blob = item.getAsFile();
      const img = new Image();

      img.onload = () => {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Optionally scale to fit canvas
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        const x = (canvas.width - img.width * scale) / 2;
        const y = (canvas.height - img.height * scale) / 2;
        ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

        // Clean up object URL
        URL.revokeObjectURL(img.src);
      };

      img.src = URL.createObjectURL(blob);

      // Prevent default so it doesn‚Äôt paste the image into any text input
      e.preventDefault();
      break;
    }
  }
});

defaultStart();

// tubes();
//vortex();
</script>
</body>
</html>